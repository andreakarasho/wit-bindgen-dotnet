using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using WitBindgen.SourceGenerator.Models;

namespace WitBindgen.SourceGenerator.Generators.Guest;

/// <summary>
/// Top-level orchestrator that generates guest code for WIT worlds.
/// Calls GuestTypeWriter for shared data types, GuestImportWriter for imports,
/// and GuestExportWriter for exports.
/// </summary>
public static class GuestWriter
{
    /// <summary>
    /// Generates all guest bindings for the given WIT packages.
    /// </summary>
    public static void GenerateGuestBindings(
        SourceProductionContext context,
        ImmutableArray<KeyValuePair<WitPackageName, WitPackage>> packages)
    {
        if (packages.IsDefaultOrEmpty)
            return;

        var resolver = new ProjectTypeContainerResolver(packages.Select(p => p.Value));

        foreach (var kv in packages)
        {
            var package = kv.Value;

            foreach (var versionKv in package.Versions)
            {
                var version = versionKv.Value;

                // Generate types from top-level definitions (interfaces at package level)
                GeneratePackageTypes(context, kv.Key, versionKv.Key, version, resolver);

                // Generate world bindings
                foreach (var worldKv in version.Worlds)
                {
                    GenerateWorld(context, kv.Key, versionKv.Key, worldKv.Key, worldKv.Value, resolver);
                }
            }
        }
    }

    private static void GeneratePackageTypes(
        SourceProductionContext context,
        WitPackageName packageName,
        SemVer version,
        WitPackageVersion packageVersion,
        ITypeContainerResolver resolver)
    {
        var sb = new IndentedStringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        var hasContent = false;

        foreach (var item in packageVersion.Definitions.Items)
        {
            if (item is WitInterface interf)
            {
                var moduleName = BuildInterfaceModuleName(packageName, version, interf.Name);

                var typeMap = BuildTypeNameMap(interf.Definitions, null);
                CanonicalAbi.SetTypeNameMap(typeMap);
                CanonicalAbi.SetResolver(resolver);

                // Write both types and any function stubs for the interface
                sb.AppendLine($"namespace Wit.{GetNamespacePath(packageName)}");
                using (sb.Block())
                {
                    sb.AppendLine($"public static unsafe partial class {interf.CSharpName}");
                    using (sb.Block())
                    {
                        GuestTypeWriter.WriteAllTypes(sb, interf.Definitions, moduleName);
                    }
                }
                sb.AppendLine();
                hasContent = true;

                CanonicalAbi.SetTypeNameMap(null);
                CanonicalAbi.SetResolver(null);
            }
        }

        if (hasContent)
        {
            var hintName = $"Wit.{packageName.FullName.Replace(":", ".").Replace("/", ".")}.Types.g.cs";
            context.AddSource(SanitizeHintName(hintName), sb.ToString());
        }
    }

    private static void GenerateWorld(
        SourceProductionContext context,
        WitPackageName packageName,
        SemVer version,
        string worldName,
        WitWorld world,
        ITypeContainerResolver resolver)
    {
        var sb = new IndentedStringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        var namespaceName = $"Wit.{GetNamespacePath(packageName)}";

        var worldTypeMap = BuildTypeNameMap(world.Definitions, resolver);
        CanonicalAbi.SetTypeNameMap(worldTypeMap);
        CanonicalAbi.SetResolver(resolver);

        sb.AppendLine($"namespace {namespaceName}");
        using (sb.Block())
        {
            // Gather imports and exports
            var imports = world.Definitions.FindAll<WitWorldImport>(resolver);
            var exports = world.Definitions.FindAll<WitWorldExport>(resolver);

            // Write world-level types
            foreach (var item in world.Definitions.Items)
            {
                switch (item)
                {
                    case WitRecord record:
                        GuestTypeWriter.WriteRecord(sb, record);
                        sb.AppendLine();
                        break;
                    case WitEnum @enum:
                        GuestTypeWriter.WriteEnum(sb, @enum);
                        sb.AppendLine();
                        break;
                    case WitFlags flags:
                        GuestTypeWriter.WriteFlags(sb, flags);
                        sb.AppendLine();
                        break;
                    case WitVariant variant:
                        GuestTypeWriter.WriteVariant(sb, variant);
                        sb.AppendLine();
                        break;
                }
            }

            // Write imports
            foreach (var import in imports)
            {
                WriteImport(sb, packageName, version, import, resolver);
                sb.AppendLine();
            }

            // Write exports
            if (exports.Length > 0)
            {
                sb.AppendLine($"public static unsafe partial class {world.CSharpName}");
                using (sb.Block())
                {
                    foreach (var export in exports)
                    {
                        WriteExport(sb, packageName, version, worldName, export, resolver);
                        sb.AppendLine();
                    }
                }
            }
        }

        CanonicalAbi.SetTypeNameMap(null);
        CanonicalAbi.SetResolver(null);

        var hintName = $"Wit.{packageName.FullName.Replace(":", ".").Replace("/", ".")}.{worldName}.g.cs";
        context.AddSource(SanitizeHintName(hintName), sb.ToString());
    }

    private static void WriteImport(
        IndentedStringBuilder sb,
        WitPackageName packageName,
        SemVer version,
        WitWorldImport import,
        ITypeContainerResolver resolver)
    {
        var type = import.Type;

        if (type is WitFuncType funcType)
        {
            // Direct function import (not through an interface)
            sb.AppendLine($"public static unsafe partial class Imports");
            using (sb.Block())
            {
                GuestImportWriter.WriteImportFunction(sb, "Imports", "$root", import.ImportName, funcType);
            }
        }
        else if (type is WitInterfaceType interfaceType)
        {
            var moduleName = import.ImportName;
            // Inline interface
            sb.AppendLine($"public static unsafe partial class {StringUtils.GetName(import.ImportName)}");
            using (sb.Block())
            {
                foreach (var field in interfaceType.Fields)
                {
                    if (field.Type is WitFuncType ft)
                    {
                        GuestImportWriter.WriteImportFunction(sb, StringUtils.GetName(import.ImportName), moduleName, field.Name, ft);
                        sb.AppendLine();
                    }
                }
            }
        }
        else if (type is WitCustomType customType)
        {
            // Reference to an interface defined elsewhere
            var resolved = customType.Resolve(resolver);
            if (resolved is WitInterfaceType resolvedInterface)
            {
                var moduleName = BuildCustomTypeModuleName(customType, version);
                sb.AppendLine($"public static unsafe partial class {StringUtils.GetName(import.ImportName)}");
                using (sb.Block())
                {
                    foreach (var field in resolvedInterface.Fields)
                    {
                        if (field.Type is WitFuncType ft)
                        {
                            GuestImportWriter.WriteImportFunction(sb, StringUtils.GetName(import.ImportName), moduleName, field.Name, ft);
                            sb.AppendLine();
                        }
                    }
                }
            }
        }
    }

    private static void WriteExport(
        IndentedStringBuilder sb,
        WitPackageName packageName,
        SemVer version,
        string worldName,
        WitWorldExport export,
        ITypeContainerResolver resolver)
    {
        var type = export.Type;

        if (type is WitFuncType funcType)
        {
            GuestExportWriter.WriteExportFunction(sb, export.ExportName, export.ExportName, funcType);
        }
        else if (type is WitInterfaceType interfaceType)
        {
            var moduleName = export.ExportName;
            foreach (var field in interfaceType.Fields)
            {
                if (field.Type is WitFuncType ft)
                {
                    var entryPoint = $"{moduleName}#{field.Name}";
                    GuestExportWriter.WriteExportFunction(sb, entryPoint, field.Name, ft);
                    sb.AppendLine();
                }
            }
        }
        else if (type is WitCustomType customType)
        {
            var resolved = customType.Resolve(resolver);
            if (resolved is WitInterfaceType resolvedInterface)
            {
                var moduleName = BuildCustomTypeModuleName(customType, version);
                foreach (var field in resolvedInterface.Fields)
                {
                    if (field.Type is WitFuncType ft)
                    {
                        var entryPoint = $"{moduleName}#{field.Name}";
                        GuestExportWriter.WriteExportFunction(sb, entryPoint, field.Name, ft);
                        sb.AppendLine();
                    }
                }
            }
        }
    }

    private static string BuildInterfaceModuleName(WitPackageName packageName, SemVer version, string interfaceName)
    {
        var ns = string.Join(":", packageName.Namespace);
        var name = packageName.Name.Length > 0 ? packageName.Name[0] : "";
        var versionStr = version.IsDefault ? "" : $"@{version}";
        return $"{ns}:{name}/{interfaceName}{versionStr}";
    }

    private static string BuildCustomTypeModuleName(WitCustomType customType, SemVer version)
    {
        var packageName = customType.Package.PackageName;
        var ver = customType.Package.Version.IsDefault ? version : customType.Package.Version;
        var versionStr = ver.IsDefault ? "" : $"@{ver}";
        return $"{packageName}/{customType.Name}{versionStr}";
    }

    private static string GetNamespacePath(WitPackageName packageName)
    {
        var parts = new List<string>();
        foreach (var ns in packageName.Namespace)
        {
            parts.Add(StringUtils.GetName(ns));
        }
        foreach (var name in packageName.Name)
        {
            parts.Add(StringUtils.GetName(name));
        }
        return string.Join(".", parts);
    }

    private static string SanitizeHintName(string name)
    {
        return name.Replace("@", "_").Replace(":", "_");
    }

    private static Dictionary<string, string> BuildTypeNameMap(
        WitTypeDefinitions definitions,
        ITypeContainerResolver? resolver)
    {
        var map = new Dictionary<string, string>(StringComparer.Ordinal);

        foreach (var item in definitions.Items)
        {
            if (item is WitTypeAlias alias)
            {
                // Type alias (e.g., type type-path = string;) â†’ resolve to underlying C# type
                map[alias.Name] = CanonicalAbi.WitTypeToCS(alias.Type);
            }
            else if (item is WitUse use && resolver != null)
            {
                // use-imported types from another package/interface
                var nsPath = GetNamespacePath(use.Package.PackageName);
                var interfaceName = StringUtils.GetName(use.Interface);

                // Try to resolve the source interface to check for type aliases
                ITypeContainer? interfaceContainer = null;
                try
                {
                    var sourceContainer = resolver.Resolve(use.Package);
                    sourceContainer.TryGetContainer(use.Interface, out interfaceContainer);
                }
                catch
                {
                    // ignore resolution failures
                }

                foreach (var useItem in use.Items)
                {
                    // Check if the source type is a type alias to a primitive
                    if (interfaceContainer != null &&
                        interfaceContainer.TryGetType(useItem.Name, out var sourceType) &&
                        IsPrimitiveKind(sourceType.Kind))
                    {
                        map[useItem.Alias] = CanonicalAbi.WitTypeToCS(sourceType);
                    }
                    else
                    {
                        // Complex type from another package - use fully qualified name
                        var typeName = StringUtils.GetName(useItem.Name);
                        map[useItem.Alias] = $"global::Wit.{nsPath}.{interfaceName}.{typeName}";
                    }
                }
            }
        }

        return map;
    }

    private static bool IsPrimitiveKind(WitTypeKind kind) => kind switch
    {
        WitTypeKind.Bool or WitTypeKind.U8 or WitTypeKind.U16 or WitTypeKind.U32 or WitTypeKind.U64
            or WitTypeKind.S8 or WitTypeKind.S16 or WitTypeKind.S32 or WitTypeKind.S64
            or WitTypeKind.F32 or WitTypeKind.F64 or WitTypeKind.Char or WitTypeKind.String => true,
        _ => false
    };
}
